-- 175. Combine Two Tables
SELECT
FirstName,
LastName,
City,
State 
FROM Person AS p 
LEFT JOIN Address AS a 
ON p.PersonId == a.PersonId


-- 176. Second Highest Salary
SELECT
t.Salary AS SecondHighestSalary 
FROM
(
SELECT
Salary,
DENSE_RANK() OVER (ORDER BY Salary DESC) AS nth
FROM Employee AS e
) AS t
WHERE t.nth == 2

/* solution:
SELECT 
    IFNULL(
        (SELECT Distinct Salary
        FROM Employee
        ORDER BY Salary Desc
        LIMIT 1 OFFSET 1),
        NULL
    ) as SecondHighestSalary
*/



-- 177. Nth Highest Salary
SELECT
IFNULL(
    SELECT
    Salary AS getNthHighestSalary 
    FROM (
        SELECT
        Salary,
        DENSE_RANK() OVER (ORDER BY Salary DESC) AS rank
        FROM Employee
    ) t_1
    WHERE rank == n, NULL
)



-- 178. Rank Scores
SELECT
Score,
DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank
FROM Score

/* solution (use row_number):
SELECT s.score, u.rank
FROM Scores s
LEFT JOIN(
    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`
    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d
) u
ON s.score=u.score
ORDER BY score DESC
*/


-- 180. Consecutive Numbers
SELECT DISTINCT
Num 
FROM
(
SELECT
l1.Id,
l1.Num AS 1st_num,
l2.Num AS 2nd_num,
l3.Num AS 3rd_num 
FROM Logs l1 
JOIN Logs l2
ON l1.Id == l2.Id - 1
JOIN Logs l3
ON l1.Id == l3.Id - 2
) temp
WHERE 1st_num == 2nd_num AND 2nd_num == 3rd_num

/* solution:
WITH cte AS ( 
    SELECT Num, LEAD(Num) OVER(ORDER BY Id) AS Num2, LAG(Num) OVER(ORDER BY Id) AS Num3
    FROM logs
    ) 
SELECT Distinct NUM as ConsecutiveNums
FROM cte
WHERE Num = Num2 AND Num2 = Num3;

SELECT distinct ConsecutiveNums from (
    SELECT 
    CASE 
        WHEN 
			((lead(num,1) over(order by id)) = num) AND 
			((lead(num,2) over(order by id)) = num)  
		THEN
			num 
		END as ConsecutiveNums 
    FROM logs
)  a
WHERE ConsecutiveNums IS NOT NULL
*/


-- 181. Employees Earning More Than Their Managers
SELECT
e.Name AS Employee
FROM Employee AS e 
JOIN Employee AS m 
ON e.ManagerId == m.Id
WHERE e.Salary > m.Salary

/* solution:
SELECT e1.Name AS Employee FROM Employee AS e1, Employee AS e2
WHERE e1.ManagerId = e2.Id AND E1.Salary > E2.Salary
*/


-- 182. Duplicate Emails
SELECT
Email 
FROM (
    SELECT
    Email,
    count(Email) AS num
    FROM Person 
    GROUP BY Email 
) temp 
WHERE num >= 2

/* solution:
SELECT Email FROM Person
GROUP BY Email HAVING COUNT(*) > 1
*/



-- 183. Customers Who Never Order
SELECT
Name
FROM Customers c 
WHERE Id NOT IN (SELECT DISTINCT CustomerId FROM Orders)


SELECT 
c.Name AS Customers
FROM Customers c 
LEFT JOIN Orders o 
ON c.Id = o.CustomerId
WHERE o.Id IS NULL


-- 1378. Replace Employee ID With The Unique Identifier
select
i.unique_id,
e.name
from Employees as e 
left join EmployeeUNI as i
on e.id == i.id

-- 1384. Total Sales Amount by Year

select
product_id,
product_name,
y as report_year,
average_daily_sales * num_days as total_amount
from
(
select 
*,
year(period_start) as y,
month(period_start) as m, 
days(period_end - period_start) as num_days,
from Product as p 
left join Sales as s 
on p.product_id == s.product_id
) as temp
group by product_id, y 
order by product_id, y 

/* solution:
SELECT 
temp.product_id, 
product_name, 
report_year, 
total_amount
FROM
(
SELECT 
product_id,
'2018' AS report_year,
average_daily_sales * (DATEDIFF(LEAST(period_end, '2018-12-31'), GREATEST(period_start, '2018-01-01')) + 1) AS total_amount
FROM Sales
WHERE period_end>='2018-01-01'
AND period_start<='2018-12-31'
UNION ALL
SELECT 
product_id, 
'2019',
average_daily_sales*(DATEDIFF(LEAST(period_end,'2019-12-31'),GREATEST(period_start,'2019-01-01'))+1) 
FROM Sales
WHERE period_end>='2019-01-01'
AND period_start<='2019-12-31'
UNION ALL 
SELECT 
product_id,
'2020',
average_daily_sales*(DATEDIFF(LEAST(period_end,'2020-12-31'),GREATEST(period_start,'2020-01-01'))+1) 
FROM Sales
WHERE period_end>='2020-01-01'
AND period_start<='2020-12-31'
) AS temp
INNER JOIN Product ON product_id
ORDER BY temp.product_id, report_year 
*/

-- 1393 Capital Gain/Loss
SELECT
stock_name,
(lst_sell_price - ori_buy_price) as capital_gain_loss
FROM (
    SELECT
    stock_name,
    FIRST(price) AS ori_buy_price
    FROM (
        SELECT 
        stock_name,
        operation_day,
        price
        FROM Stocks
        WHERE operation == 'Buy'
        ORDER BY operation_day ASC
        ) AS buy
    GROUP BY stock_name 
    ) AS a
JOIN (
    SELECT
    stock_name, 
    FIRST(price) AS lst_sell_price
    FROM (
        select
        stock_name, 
        operation_day,
        price
        FROM Stocks
        WHERE operation == 'Sell'
        ORDER BY operation_day DESC
        ) AS sell
    GROUP BY stock_name
    ) AS b
ON a.stock_name == b.stock_name

/* solution:
SELECT 
stock_name,
SUM(price) - 2 * SUM(CASE WHEN operation == 'Buy', THEN price ELSE 0 END) as capital_gain_loss
FROM Stocks
GROUP BY stock_name 
*/

-- 1398 Customers Who Bought Products A and B but Not C
SELECT
customer_id,
customer_name,
CASE WHEN product_name
FROM Customers AS c
LEFT JOIN (
SELECT 
customer_id,
product_name
count(order_id) AS num_orders
FROM Orders AS o  
WHERE o.product_name in ('A', 'B', 'C')
GROUP BY customer_id, product_name
) AS temp

/* try out:
Use

HAVING sum(ea.gender = 'female') > 0 
   AND sum(ea.gender = 'male') > 0
or

HAVING count(distinct ea.gender) = 2
*/


/* solution:
select customer_id, customer_name
from (
    select distinct c.customer_id, c.customer_name, o.product_name, 
    case when o.product_name = 'A' or o.product_name = 'B' then 1
    when o.product_name = 'C' Then -2 END as qualifers 
    from customers c
    left join orders o
    on c.customer_id = o.customer_id
) as tmp1 
group by customer_id 
having sum(qualifers) = 2
*/

-- 1407. Top Travellers
SELECT 
u.id,
u.name,
COALESCE(sum(r.distance), 0) AS travelled_distance
FROM Users AS u 
LEFT JOIN Rides AS r 
ON u.id == r.user_id
GROUP BY u.id, u.name 
ORDER BY travelled_distance DESC, u.name ASC


-- 1412. Find the Quiet Students in All Exams

SELECT 
student_id
student_name,
COUNT(exam_id) AS num_exams, 
SUM(CASE WHEN score IS NULL THEN 1 else 0 END) as num_na_scores
FROM Student AS s
JOIN Exam AS e
ON s.student_id == e.student_id
GROUP BY student_id, student_name 
HAVING num_exams > 1 AND num_na_scores > 1

/* solution:
WITH top_bot_students AS (
    SELECT 
    exam_id,
    student_id,
    score,
    highest_score,
    lowest_score
    from Exam as e
    JOIN (
        SELECT
        exam_id, 
        max(score) as highest_score,
        min(score) as lowest_score
        FROM Exam as e_1
        GROUP BY exam_id
        )
    WHERE score == highest_score OR score == lowest_score
)

SELECT DISTINCT
student_id,
student_name,
tbs.score AS top_bot_score
FROM Student as s
LEFT JOIN (
    SELECT 
    student_id,
    count(exam_id) AS num_exams
    FROM Exam AS e
    GROUP BY student_id
) AS ne
ON s.student_id == ne.student_id
LEFT JOIN top_bot_students AS tbs
ON s.student_id == tbs.student_id
WHERE num_exams > 1 AND top_bot_score IS NULL
*/


-- 1421. NPV Queries
SELECT
q.id,
q.year,
COALESCE(n.npv, 0) AS npv
FROM Queries AS q
LEFT JOIN NPV AS n
ON (q.id, q.year) == (n.id, n.year)
ORDER BY q.id


-- 1435. Create a Session Bar Chart
WITH bin_table AS (
SELECT
session_id,
CASE WHEN duration < 5 THEN '[0-5>'
     WHEN duration >= 5 AND duration < 10 THEN '5-10>'
     WHEN duration >= 10 AND duration <15 THEN '10-15>'
     ELSE '15 or more' END AS bin,
FROM Sessions
)

SELECT 
bin,
count(session_id) AS total_amount
FROM bin_table
ORDER BY bin;

/* solution:
select '[0-5>' as bin, count(if(duration < 300,1,null)) as total from sessions union
select '[5-10>' as bin, count(if(duration >= 300 and duration < 600,1,null)) as total from sessions union
select '[10-15>' as bin, count(if(duration >= 600 and duration < 900,1,null)) as total from sessions union
select '15 or more' as bin, count(if(duration >= 900,1,null)) as total from sessions
*/
 

-- 1440. Evaluate Boolean Expression
SELECT
v_l.value AS left_operand,
e.operator,
v_r.value AS right_operand,
CASE WHEN e.operator == '>' THEN v_l.value > v_r.value
     WHEN e.operator == '=' THEN v_l.value = v_r.value 
     ELSE v_l.value < v_r.value END AS value
FROM Expressions AS e 
JOIN Variables AS v_l
ON e.left_operand == v_l.name
JOIN Variables AS v_r 
ON e.right_operand == v_r.name 


-- 1445. Apples & Oranges
SELECT
sale_date,
num_apples - num_oranges AS diff 
FROM (
(
SELECT
sale_date,
sum(sold_num) AS num_apples
FROM Sales
WHERE fruit == 'apples'
) AS a
OUTER JOIN (
    SELECT
    sale_date, 
    sum(sold_num) AS num_oranges
    FROM Sales
    WHERE fruit == 'oranges'
) AS o
ON a.sale_date == o.sales_date
)

-- 1454. Active Users

(
SELECT
id,
login_date AS 1st
1 AS c_1
FROM Logins
ORDER BY id, login_date
) a
JOIN (
    SELECT 
    id, 
    login_date - 1 AS 2nd
    FROM Logins
    ORDER BY id, login_date
) b
ON a.login_date == b.login_date - 1
JOIN (
    SELECT
    id, 
    login_date - 2 AS 3rd
    FROM Logins
    ORDER BY id, login_date
)
JOIN (
    id, 
    login_date - 3 AS 4th
    FROM Logins
    ORDER BY id, login_date
)
JOIN (
    id,
    login_date - 5 AS 5th
    FROM Logins
    ORDER BY id, login_date
)

/* try out:
SELECT *, sum(some_value) OVER (
        PARTITION BY Cust_ID 
        ORDER BY CAST(Purch_Date AS timestamp) 
        RANGE BETWEEN 6 PRECEDING AND CURRENT ROW
     ) AS cummulativeSum FROM Spend_Table
*/

/* solution:
SELECT          DISTINCT l1.id, a.name
FROM            Logins l1
LEFT JOIN       Accounts a
ON              l1.id = a.id
WHERE           date_add(l1.login_date, 1) in (SELECT login_date from Logins l2 where l2.id = l1.id)
AND             date_add(l1.login_date, 2) in (SELECT login_date from Logins l3 where l3.id = l1.id)
AND             date_add(l1.login_date, 3) in (SELECT login_date from Logins l4 where l4.id = l1.id)
AND             date_add(l1.login_date, 4) in (SELECT login_date from Logins l5 where l5.id = l1.id)
ORDER BY 1 */


-- 1459. Rectangles Area
SELECT
p1.id AS p1,
p2.id AS p2,
abs(p1.x_value - p2.x_value) * abs(p1.y_value - p2.y_value) AS area
FROM Points AS p1
OUTER JOIN Points AS p2
ON p1.id < p2.id 
WHERE p1.x_value != p2.x_value AND p1.y_value != p2.y_value
ORDER BY area DESC


-- 1468. Calculate Salaries
SELECT
company_id,
employee_id,
employee_name,
round(salary - tax * salary) AS salary
FROM Salaries AS s
JOIN 
(
SELECT 
company_id,
CASE WHEN max(salary) < 1000 THEN 0
     WHEN max(salary) BETWEEN 1000 AND 10000 THEN 0.24
     WHEN max(salary) > 10000 THEN 0.49 END AS tax
FROM Salaries
GROUP BY company_id
) AS t
ON s.company_id == t.company_id


-- 1479. Sales by Day of the Week
CREATE TEMPORARY TABLE temp AS 
(
SELECT 
order_id, 
customer_id,
order_date,
item_id,
item_name, 
item_category,
quantity
FROM Items AS i
LEFT JOIN Orders AS o
ON i.item_id == o.item_id
)

SELECT 
m.item_category,
COALESCE(sum(quantity), 0) AS Monday
FROM temp AS m
WHERE weekday(order_date) == 'monday'
GROUP BY item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Tuesday
    FROM temp
    WHERE weekday(order_date) == 'tuesday'
    GROUP BY item_category
) AS t
ON m.item_category == t.item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Wednesday
    FROM temp 
    WHERE weekday(order_date) == 'wednesday'
    GROUP BY item_category
) AS w
ON m.item_category == w.item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Thursday
    FROM temp
    WHERE weekday(order_date) == 'thursday'
    GROUP BY item_category
) AS th
ON m.item_category == th.item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Friday
    FROM temp
    WHERE weekday(order_date) == 'friday'
    GROUP BY item_category
) AS f
ON m.item_category == f.item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Saturday
    FROM temp
    WHERE weekday(order_date) == 'saturday'
    GROUP BY item_category
) AS sa
ON m.item_category == sa.item_category
JOIN (
    SELECT 
    item_category,
    COALESCE(sum(quantity), 0) AS Sunday
    FROM temp
    WHERE weekday(order_date) == 'sunday'
    GROUP BY item_category
) AS su
ON m.item_category == su.item_category 

/* solution:
select 
a.item_category as Category,
sum(case when a.day = 'Monday' then a.quantity else 0 end) as Monday,
sum(case when a.day = 'Tuesday' then a.quantity else 0 end) as Tuesday,
sum(case when a.day = 'Wednesday' then a.quantity else 0 end) as Wednesday,
sum(case when a.day = 'Thursday' then a.quantity else 0 end) as Thursday,
sum(case when a.day = 'Friday' then a.quantity else 0 end) as Friday,
sum(case when a.day = 'Saturday' then a.quantity else 0 end) as Saturday,
sum(case when a.day = 'Sunday' then a.quantity else 0 end) as Sunday
from
(
select 
o.quantity,
i.item_category,
date_format(o.order_date, 'u') as day
from orders as o 
right join items as i 
on o.item_id == i.item_id)
) as a           
group by Category order by Category;
*/


-- 1484. Group Sold Products By The Date

SELECT
sell_date,
count(product) AS num_sold,
group_concat(product ORDER BY product) AS products
FROM
(
SELECT DISTINCT
sell_date,
product
FROM Activities
)
GROUP BY sell_date



-- 1495. Friendly Movies Streamed Last Month
SELECT
DISTINCT title
FROM TVProgram AS t
JOIN Content AS c
ON t.content_id == c.content_id
WHERE program_date BETWEEN '06-01-2020' AND '06-30-2020' AND Kids_content == 'Y'


-- 1501. Countries You Can Safely Invest In

SELECT
co.name AS country,
avg(c.duration) AS avg_duration
FROM Calls AS c 
JOIN Person AS p 
ON c.caller_id == p.id
JOIN Country AS co 
ON substr(p.phone_number, 1, 3) == co.country_code
GROUP BY co.name HAVING avg(c.duration) > (SELECT avg(duration) FROM Calls)
ORDER BY co.name



-- 1511. Customer Order Frequency
SELECT
customer_id,
name
FROM
(
SELECT
c.name,
date_format(o.order_date, 'yyyy-MM') AS y_m
CASE WHEN sum(p.price * o.quantity) > 100 THEN 1 ELSE 0 AS if_greater_100
FROM Customers AS c
LEFT JOIN Orders AS o
ON c.customer_id == o.customer_id
JOIN Product AS p 
ON o.product_id == p.product_id
WHERE o.order_date BETWEEN '06-01-2020' AND '07-31-2020'
GROUP BY name, date_format(o.order_date, 'yyyy-MM')
) AS temp
GROUP BY customer_id HAVING sum(if_greater_100) == 2


-- 1517. Find Users With Valid E-Mails
SELECT
user_id,
name
FROM Users
WHERE substr(mail, 1, 1) RLIKE '[a-z][A-Z]' AND RLIKE '[a-z][A-Z][_][.][-][0-9]' AND split(mail, '[@]')[1] == 'leetcode.com'

/* solution:
1. ^[a-zA-Z] the first character should be only alphanumeric
2. [a-zA-Z0-9_.-]* the middle can contain any of these and multiple times (* is for multiple times)
3. leetcode.com$ ending should be leetcode.com ($ is for the ending)
4. On top of using the square brackets [] to identify character sets, 
   and regular brackets () to identify groupings, 
   there are a few other common characters which control the behaviour.
   * – Any number of occurrences (includes 0)
   + – One or more occurrences
   ? – 0 or 1 occurrences
   ^ – Start of line
   $ – End of line

SELECT 
* 
FROM Users 
WHERE mail RLIKE '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode.com$'
*/


-- 1527. Patients With a Condition
SELECT
*
FROM Patients
WHERE conditions RLIKE '^DIAB1$' OR '^[a-zA-Z0-9] DIAB1$';

/* solution:
SELECT * 
FROM Patients
WHERE conditions LIKE "DIAB1%" OR conditions LIKE "% DIAB1%"
*/


-- 1532. The Most Recent Three Orders
CREATE TEMPORARY TABLE temp AS
(
SELECT
c.customer_id,
c.customer_name,
order_id,
order_date,
RANK() OVER (PARTITION BY c.customer_id ORDER BY order_date DESC) AS nth_order
FROM Customers AS c
LEFT JOIN Orders AS o
ON c.customer_id == o.customer_id
)

SELECT DISTINCT
c.customer_name,
c.customer_id,
t_1.order_id,
t_1.order_date,
FROM Customers AS c
LEFT JOIN temp AS t_1
ON c.customer_id == t_1.customer_id AND t_1.nth_order == 1
UNION (
    SELECT DISTINCT
    c.customer_name,
    c.customer_id,
    t_2.order_id,
    t_2.order_date
    FROM Customers AS c
    LEFT JOIN temp AS t_2
    ON c.customer_id == t_2.customer_id AND t_2.nth_order == 2
)
UNION (
    SELECT DISTINCT
    c.customer_name,
    c.customer_id,
    t_3.order_id,
    t_3.order_date
    FROM Customers AS c
    LEFT JOIN temp AS t_3
    ON c.customer_id == t_3.customer_id AND t_3.nth_order == 3
)
ORDER BY c.customer_name ASC, c.customer_id ASC, o.order_date DESC

-- follow up: most recent n orders per customer
SELECT
customer_name,
customer_id,
order_id,
order_date,
rank() OVER (PARTITION BY customer_id ORDER BY order_date DESC) AS nth_recent_order
FROM Customers AS c 
JOIN Orders AS o 
ON c.customer_id == o.customer_id 
WHERE rank() OVER (PARTITION BY customer_id ORDER BY order_date DESC) <= n

/* try out:
ERROR:  window functions are not allowed in WHERE
LINE 3: WHERE 1 = row_number() over(PARTITION BY product_id ORDER BY amount DESC)
*/

/* solution:
with cte as
(
select o.order_id,o.order_date,o.customer_id,o.cost,c.name as customer_name,dense_rank() over(partition by o.customer_id order by order_date desc) as ranks
from Orders o
left join customers c
on O.customer_id = c.customer_id )

select customer_name,customer_id,order_id,order_date
from cte
where ranks <= 3
order by customer_name,customer_id,order_date desc
*/

-- 1543. Fix Product Name Format
SELECT
trim(lower(product_name)) AS product_name,
date_format(sale_date, 'yyyy-MM') AS sale_date,
count(sale_id)
FROM Sales AS s 
GROUP BY trim(lower(product_name)), date_format(sale_date, 'yyyy-MM')
ORDER BY trim(lower(product_name)) ASC, date_format(sale_date, 'yyyy-MM') ASC


-- 1549. The Most Recent Orders for Each Product
CREATE TEMPORARY TABLE temp AS
(
SELECT
p.product_id,
p.product_name,
o.order_id,
o.order_date,
DENSE_RANK() OVER (PARTITION BY o.product_id ORDER BY o.order_date DESC) AS nth_recent_order
FROM Orders AS o 
JOIN Products AS p 
ON o.product_id == p.product_id
)

SELECT
product_id,
product_name,
order_id,
order_date
FROM temp
WHERE nth_recent_order == 1
ORDER BY product_name, product_id, order_id; 


--1555. Bank Account Summary
SELECT
user_id,
user_name,
credit + inputs - outputs AS credit,
IF(credit + inputs - outputs < 0, 'Yes', 'No') AS credit_limit_breached
FROM Users AS u 
LEFT JOIN 
(
    SELECT
    paid_to AS user_id,
    COALESCE(sum(amount), 0) AS inputs
    FROM Transactions
    GROUP BY paid_to
) AS i
ON u.user_id == i.paid_to
LEFT JOIN 
(
    SELECT
    paid_by AS user_id,
    COALESCE(sum(amount), 0) AS outputs
    FROM Transactions
    GROUP BY paid_by
) AS o 
ON u.user_id == o.paid_by


-- 1565. Unique Orders and Customers Per Month
SELECT
date_format(order_date, 'yyyy-MM') AS month,
count(order_id) AS num_orders,
count(customer_id) AS num_customers
FROM Orders
WHERE invoice > 20
GROUP BY date_format(order_date, 'yyyy-MM') 
ORDER BY date_format(order_date, 'yyyy-MM')


-- 1571. Warehouse Manager
SELECT
w.name AS warehouse_name,
COALESCE(sum(p.Width * p.Length * p.Height * w.units), 0) AS volume
FROM Warehouse AS w 
LEFT JOIN Products AS p 
ON w.product_id == p.product_id
GROUP BY name 
ORDER BY name ASC


-- 1581. Customer Who Visited but Did Not Make Any Transactions
SELECT
customer_id,
sum(CASE WHEN t.transaction_id IS NULL OR t.amount == 0 THEN 1 ELSE 0 END) AS count_no_trans
FROM Visits AS v 
LEFT JOIN Transactions AS t 
on v.visit_id == t.visit_id
GROUP BY customer_id
ORDER BY customer_id


/* solution
Select 
    Visits.customer_id As customer_id,
    count(Visits.visit_id)  As count_no_trans
From
    Visits
Left join Transactions
    On Transactions.visit_id = Visits.visit_id 
Where
    transactions.visit_id Is Null
Group by
    Visits.customer_id
*/


-- 1587. Bank Account Summary II
SELECT
name,
COALESCE(sum(amount), 0) AS balance
FROM Users AS u 
LEFT JOIN Transactions AS t 
ON u.account == t.account
GROUP BY account
HAVING COALESCE(sum(amount), 0) > 10000
ORDER BY account


-- 1596. The Most Frequently Ordered Products for Each Customer
CREATE TEMPORARY TABLE temp AS
(
SELECT
customer_id,
product_id,
product_name,
COALESCE(count(order_date), 0) AS num_day_order 
FROM Customers AS c 
LEFT JOIN Orders AS o 
ON c.customer_id == o.customer_id 
JOIN Products AS p 
ON o.product_id == p.product_id 
GROUP BY customer_id, product_id
ORDER BY customer_id ASC, product_id ASC, count(order_date) DESC
)

SELECT
customer_id,
first(product_id),
first(product_name)
FROM temp
GROUP BY customer_id
ORDER BY customer_id, product_id, product_name;


-- 1607. Sellers With No Sales
SELECT
s.seller_name,
COALESCE(count(order_id), 0) AS o.num_orders
FROM Seller AS s 
LEFT JOIN (
    SELECT
    *
    FROM Orders 
    WHERE date_format(o.sale_date, 'yyyy') == '2020'
    ) AS o 
ON s.seller_id == o.seller_id 
GROUP BY s.seller_name HAVING COALESCE(count(o.order_id), 0) == 0

/* try out:
from_unixtime(unix_timestamp('12-03-2010' , 'dd-MM-yyyy'))
*/


-- 1613. Find the Missing IDs
SELECT
RANK(customer_id) AS customer_id
customer_id,
customer_name

FROM Customers AS c_1
JOIN (
    SELECT
    RANK(customer_id) - 1 AS nxt_customer_id
    customer_id,
    customer_name
    FROM Customers
) AS c_2
ON c_1.customer_id == c_2.customer_id


/* solution:
with recursive new as (
select 1 as ids
union all 
select ids+1
from new
where ids < (select max(customer_id) from customers))

select ids
from new 
where ids not in (
select customer_id
from customers)
*/

-- 1623. All Valid Triplets That Can Represent a Country
SELECT
a.student_name AS member_A,
b.student_name AS member_B,
c.student_name AS member_C
FROM SchoolA AS a
FULL OUTER JOIN SchoolB AS b 
ON a.student_id == b.student_id
OUTER JOIN SchoolC AS c
ON b.student_id == c.student_id
WHERE a.student_id != b.student_id 
AND b.student_id != c.student_id 
AND a.student_id != c.student_id
AND a.student_name != b.student_name 
AND b.student_name != c.student_name
AND a.student_name != c.student_name

/*
select 
a.student_name as member_A, 
b.student_name as member_B, 
c.student_name as member_C
from schoola a, schoolb b, schoolc c
where a.student_id != b.student_id and b.student_id!=c.student_id and a.student_id != c.student_id
and a.student_name != b.student_name and b.student_name!=c.student_name and a.student_name != c.student_name
*/


-- 1633. Percentage of Users Attended a Contest
SELECT
contest_id,
round(count(user_id) / (SELECT count(user_id) FROM Users) * 100, 2) AS percentage 
FROM Register AS r
GROUP BY contest_id
ORDER BY contest_id ASC, round(count(user_id) / (SELECT count(user_id) FROM Users) * 100, 2) DESC


-- 1635. Hopper Company Queries I
WITH temp AS 
(
SELECT
month(r.requested_at) AS month,
r.requested_at,
count(a.driver_id) AS active_drivers
count(a.ride_id) AS accepted_rides
FROM Drivers AS d
LEFT JOIN AcceptedRides AS a
d.driver_id == a.driver_id
JOIN Rides AS r 
a.ride_id == r.ride_id
WHERE r.requested_at BETWEEN '2020-01-01' AND '2020-12-31'
GROUP BY month(r.requested_at), r.requested_at
ORDER BY month(r.requested_at), r.requested_at
)

SELECT 
month,
last(requested_at),
last(active_drivers),
FROM temp
JOIN (
    SELECT
    month,
    sum(accepted_rides) AS accepted_rides
    FROM temp
    GROUP BY month
)


-- 1645. Hopper Company Queries II
/* active driver is defined as cumulated joined drivers */
WITH temp_2 AS (
    SELECT
    month(join_date) AS month,
    count(driver_id) AS drivers
    FROM Drivers AS d 
    GROUP BY month(join_date)
)

SELECT
a.month AS cur_month,
round(active_drivers / sum(b.drivers) * 100, 2) AS drivers
FROM temp_2 AS a
JOIN temp_2 AS b
ON a.month >= b.month
JOIN (
    SELECT
    month, 
    sum(active_drivers) AS active_drivers
    FROM temp
    GROUP BY month 
) c
ON a.month == c.month


-- 1651. Hopper Company Queries III
SELECT
month,
round(sum(distance) OVER (PARTITION BY month ORDER BY month RANGE BETWEEN 2 PRECEDING AND CURRENT ROW) / 3, 2),
round(sum(duration) OVER (PARTITION BY month ORDER BY month RANGE BETWEEN 2 PRECEDING AND CURRENT ROW) / 3, 2)
FROM
(
SELECT
month(requested_at) AS month,
sum(ride_distance) AS distance,
sum(ride_duration) AS duration
FROM Rides AS r 
LEFT JOIN AcceptedRides AS a 
ON r.ride_id == a.ride_id 
GROUP BY month(request_at)
ORDER BY month(requested_at)
)


-- 1661. Average Time of Process per Machine
WITH temp AS 
(
SELECT
a_1.machine_id,
a_1.process_id,
a_1.timestamp AS start_time
FROM Activity AS a_1
WHERE a_1.activity_type == 'start'
JOIN (
    SELECT 
    a_2.machine_id,
    a_2.process_id,
    a_2.timestamp AS end_time
    FROM Activity AS a_2
    WHERE a_2.acitvity_type == 'end'
) b_1
ON a_1.machien_id == b_1.machine_id AND a_1.process_id == b_1.process_id
)

SELECT
machine_id,
round(avg(end_time - start_time), 3) AS processing_time
FROM temp
GROUP BY machine_id
ORDER BY machine_id


-- 1667. Fix Names in a Table
SELECT
user_id,
upper(substr(name, 1, 1)) + lower(substr(name, 2, length(name - 1)) AS name
FROM Users
ORDER BY user_id


-- 1677. Product's Worth Over Invoices
SELECT
name,
sum(rest) AS rest,
sum(paid) AS paid,
sum(canceled) AS canceled,
sum(refunded) AS refunded
FROM Product AS p 
LEFT JOIN Invoice AS i 
ON p.product_id == i.product_id 
GROUP BY product_id
ORDER BY product_id


-- 1683. Invalid Tweets
SELECT
tweet_id
FROM Tweets
WHERE length(content) > 15


-- 1693. Daily Leads and Partners
SELECT
date_id,
make_name,
count(DISTINCT lead_id) AS unique_leads,
count(DISTINCT partner_id) AS unique_partners
FROM DailySales 
GROUP BY date_id, make_name 


-- 1699. Number of Calls Between Two Persons
WITH temp AS (
    SELECT 
    DISTINCT from_id AS id
    FROM Calls
    UNION (
        SELECT
        DISTINCT to_id AS id
        FROM Calls
    )
)

SELECT
t_1.id AS person1,
t_2.id AS person2,
count(duration) AS call_count,
sum(duration) AS total_duration
FROM temp AS t_1
JOIN temp AS t_2
ON t_1.id < t_2.id
LEFT JOIN Calls AS c 
ON t_1.id == c.from_id AND t_2.id == c.to_id

/* soluation:
SELECT from_id AS person1
     , to_id AS person2
     , COUNT(*) AS call_count
     , SUM(duration) AS total_duration

  FROM (
            SELECT CASE WHEN from_id > to_id THEN to_id ELSE from_id END from_id
                 , CASE WHEN from_id > to_id THEN from_id ELSE to_id END to_id
                 , duration
              FROM Calls  
       ) A
 GROUP BY from_id
        , to_id
*/


-- 1709. Biggest Window Between Visits
WITH temp AS (
    SELECT
    user_id,
    RANK() OVER (PARTITION BY user_id ORDER BY visit_date ASC) AS nth_visit
    FROM UserVisits AS uv 
)


SELECT
user_id,
max(window) AS biggest_window
FROM
(
SELECT
user_id,
CASE WHEN datediff(t_2.nth_visit - t_1.nth_visit) IS NULL THEN current_date ELSE (t_2.nth_visit - t_1.nth_visit) AS window
FROM temp AS t_1 
RIGHT JOIN temp AS t_2 
ON t_1.user_id == t_2.user_id AND t_1.nth_visit == t_2.nth_visit - 1 
) AS t
GROUP BY user_id
ORDER BY user_id


/* try out:
datediff()

/* solution:
select user_id, max(window_) as biggest_window
from (
         select user_id, datediff('2021-01-01', max(visit_date)) as window_
         from UserVisits
         group by user_id
         union
         (with numbered_table as (
             select user_id,
                    visit_date,
                    row_number() over (partition by user_id order by visit_date) as idx
             from UserVisits)
          select n1.user_id, datediff(n2.visit_date, n1.visit_date) as window_
          from numbered_table as n1,
               numbered_table as n2
          where n1.user_id = n2.user_id
            and cast(n2.idx as signed) - cast(n1.idx as signed) = 1)) as temp
group by user_id;
*/


-- 1715. Count Apples and Oranges
WITH temp AS (
SELECT
box_id,
apple_count,
orange_count
FROM Boxes AS b_1
UNION (
    SELECT
    box_id,
    c.apple_count,
    c.orange_count
    FROM Boxes AS b_3
    JOIN Boxes AS c 
    ON b_3.chest_id == c.chest_id
)
)

SELECT
sum(apple_count) AS apple_count,
sum(orange_count) AS orange(count)
FROM temp 


-- 1729. Find Followers Count
SELECT
user_id,
count(DISTINCT follower_id) AS followers_count
FROM Followers AS f 
GROUP BY user_id
ORDER BY user_id 


-- 1731. The Number of Employees Which Report to Each Employee
SELECT
e.reports_to AS employee_id,
m.name,
count(e.employee_id) AS reports_count,
round(avg(e.age), 0) AS average_age
FROM Employees AS e 
JOIN Employees AS m 
ON e.reports_to == m.employee_id
GROUP BY e.reports_to, m.name
ORDER BY e.reports_to, m.name

-- 1741. Find Total Time Spent by Each Employee
SELECT
emp_id,
event_day
sum(out_time - in_time) AS total_time
FROM Employees AS e 
GROUP BY emp_id, event_day
ORDER BY emp_id, event_day



-- 1747. Leetflex Banned Accounts
WITH temp AS (
    SELECT
    account_id,
    ip_address,
    login,
    logout
    RANK() OVER (PARTITION BY account_id ORDER BY login) AS nth_rank
    FROM LogInfo
    ORDER BY account_id, login, logout
)

SELECT DISTINCT
l1.account_id,
FROM temp AS l1
JOIN temp AS l2
ON l1.account_id == l2.account_id AND l1.nth_rank == l2.nth_rank - 1
WHERE l2.login BETWEEN l1.login AND l1.logout AND l1.ip_address != l2.ip_address


/* solution:
with t1 as (
select a.account_id, a.ip_address, a.login as login_a, a.logout as logout_a, b.ip_address as ip_address_2, b.login as login_b, b.logout as logout_b
from LogInfo a
join LogInfo b
on a.account_id = b.account_id and a.ip_address != b.ip_address
)
select distinct account_id
from t1
where (login_a <= login_b and logout_a >= logout_b) or (login_b <= login_a and logout_b >= logout_a) or (login_a <= login_b and login_b <= logout_a) or (login_b <= login_a and login_a <= logout_b);
*/

-- 1757. Recyclable and Low Fat Products
SELECT
product_id
FROM Products AS p 
WHERE low_facts == 'Y' AND recyclable == 'Y'


-- 1767. Find the Subtasks That Did Not Execute
SELECT DISTINCT
t.task_id,
FROM Tasks AS t 
LEFT JOIN (
SELECT
task_id,
count(subtask_id) AS num_exec_subtasks
FROM Executed) AS st 
ON t.task_id == st.task_id 
WHERE t.subtasks_count > st.num_exec_subtasks

/* solution:
with recursive cte as ( select task_id, 1 as subtask_id , subtasks_count from tasks
union all
select task_id, subtask_id+1 as subtask_id, subtasks_count from cte where subtask_id<subtasks_count)

select c.task_id, c.subtask_id
from cte c
where (c.task_id, c.subtask_id) not in (select task_id, subtask_id from executed)
*/


-- 1777. Product's Price for Each Store
SELECT
product_id,
first(CASE WHEN store == 'store1' THEN price ELSE 0 END) AS store1,
first(CASE WHEN store == 'store2' THEN price ELSE 0 END) AS store2,
first(CASE WHEN store == 'store3' THEN price ELSE 0 END) AS store3
FROM Products
GROUP BY product_id
ORDER BY product_id

